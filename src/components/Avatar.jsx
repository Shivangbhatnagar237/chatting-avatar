/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 models/68624e8f35fff28602dbc860.glb 
*/

import React, { useRef, useMemo, useEffect } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'

const VISEME_MAP = {
  "A": "aa",
  "I": "ih",
  "E": "ee",
  "O": "oh",
  "U": "ou",
  // Add more if your TTS outputs others
};

const MOUTH_VISEMES = [
  "mouthOpen", "viseme_aa", "viseme_ih", "viseme_oh", "viseme_ou", "viseme_ee", "viseme_ae"
];

const BLINK_MORPHS = ["eyeBlinkLeft", "eyeBlinkRight"];

const Avatar = React.forwardRef(
  ({ visemeSequence, audioStartTime, isSpeaking, lookTarget, ...props }, ref) => {
    const group = useRef();
    const { scene } = useGLTF('models/68624e8f35fff28602dbc860.glb');
    const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
    const { nodes, materials } = useGraph(clone);

    const blinkState = useRef({
      blinking: false,
      blinkValue: 0,
      blinkStart: 0,
      nextBlink: performance.now() + 2000 + Math.random() * 3000,
    });

    // Helper: Reset all viseme morphs to 0
    const resetMorphs = (mesh, morphs) => {
      if (!mesh?.morphTargetDictionary || !mesh?.morphTargetInfluences) return;
      morphs.forEach(morph => {
        const idx = mesh.morphTargetDictionary[morph];
        if (idx !== undefined) mesh.morphTargetInfluences[idx] = 0;
      });
    };

    // Helper: Set a single morph to value, others to 0
    const setSingleMorph = (mesh, morphs, activeMorph, value = 1) => {
      if (!mesh?.morphTargetDictionary || !mesh?.morphTargetInfluences) return;
      morphs.forEach(morph => {
        const idx = mesh.morphTargetDictionary[morph];
        if (idx !== undefined) {
          mesh.morphTargetInfluences[idx] = morph === activeMorph ? value : 0;
        }
      });
    };

    
    useFrame(() => {
      // if (nodes.Wolf3D_Head && nodes.Wolf3D_Head.morphTargetDictionary["mouthOpen"] !== undefined) {
      //     nodes.Wolf3D_Head.morphTargetInfluences[nodes.Wolf3D_Head.morphTargetDictionary["mouthOpen"]] = 1; // 1 = fully open
      //   }
      //   if (nodes.Wolf3D_Teeth && nodes.Wolf3D_Teeth.morphTargetDictionary["mouthOpen"] !== undefined) {
      //     nodes.Wolf3D_Teeth.morphTargetInfluences[nodes.Wolf3D_Teeth.morphTargetDictionary["mouthOpen"]] = 1;
      //   }
      // const now = performance.now();
      // const blink = blinkState.current;
      // if (!blink.blinking && now > blink.nextBlink) {
      //   blink.blinking = true;
      //   blink.blinkStart = now;
      // }
      // if (blink.blinking) {
      //   // Animate blink: 0 -> 1 (close) -> 0 (open)
      //   const t = (now - blink.blinkStart) / 180; // 180ms for full blink
      //   let blinkValue = t < 0.5 ? t * 2 : 2 - t * 2;
      //   blinkValue = Math.max(0, Math.min(1, blinkValue));
      //   if (nodes.EyeLeft && nodes.EyeLeft.morphTargetDictionary["eyeBlinkLeft"] !== undefined) {
      //     nodes.EyeLeft.morphTargetInfluences[nodes.EyeLeft.morphTargetDictionary["eyeBlinkLeft"]] = blinkValue;
      //   }
      //   if (nodes.EyeRight && nodes.EyeRight.morphTargetDictionary["eyeBlinkRight"] !== undefined) {
      //     nodes.EyeRight.morphTargetInfluences[nodes.EyeRight.morphTargetDictionary["eyeBlinkRight"]] = blinkValue;
      //   }
      //   if (t >= 1) {
      //     blink.blinking = false;
      //     blink.nextBlink = now + 2000 + Math.random() * 3000;
      //   }
      // } else {
      //   // Keep eyes open
      //   if (nodes.EyeLeft && nodes.EyeLeft.morphTargetDictionary["eyeBlinkLeft"] !== undefined) {
      //     nodes.EyeLeft.morphTargetInfluences[nodes.EyeLeft.morphTargetDictionary["eyeBlinkLeft"]] = 0;
      //   }
      //   if (nodes.EyeRight && nodes.EyeRight.morphTargetDictionary["eyeBlinkRight"] !== undefined) {
      //     nodes.EyeRight.morphTargetInfluences[nodes.EyeRight.morphTargetDictionary["eyeBlinkRight"]] = 0;
      //   }
      // }

      // // --- Head and eye movement ---
      // // lookTarget.x/y in [-1, 1], 0 is center
      // const head = nodes.Wolf3D_Head;
      // if (head) {
      //   // Smoothly interpolate head rotation towards target
      //   const targetY = lookTarget.x * 0.15; // left/right
      //   const targetX = -0.05 + lookTarget.y * 0.08; // up/down
      //   head.rotation.y += (targetY - head.rotation.y) * 0.2;
      //   head.rotation.x += (targetX - head.rotation.x) * 0.2;
      // }
      // // Eyes: move morphs for look direction
      // const setEyeLook = (eye, x, y) => {
      //   if (!eye?.morphTargetDictionary || !eye?.morphTargetInfluences) return;
      //   const dict = eye.morphTargetDictionary;
      //   if (dict["eyeLookLeft"] !== undefined)
      //     eye.morphTargetInfluences[dict["eyeLookLeft"]] = Math.max(0, -x * 1.2);
      //   if (dict["eyeLookRight"] !== undefined)
      //     eye.morphTargetInfluences[dict["eyeLookRight"]] = Math.max(0, x * 1.2);
      //   if (dict["eyeLookUp"] !== undefined)
      //     eye.morphTargetInfluences[dict["eyeLookUp"]] = Math.max(0, -y * 1.2);
      //   if (dict["eyeLookDown"] !== undefined)
      //     eye.morphTargetInfluences[dict["eyeLookDown"]] = Math.max(0, y * 1.2);
      // };
      // setEyeLook(nodes.EyeLeft, lookTarget.x, lookTarget.y);
      // setEyeLook(nodes.EyeRight, lookTarget.x, lookTarget.y);
      
      // Animate mouth using viseme sequence if available
      if (visemeSequence) {
        const elapsed = performance.now() / 1000 - audioStartTime;
        // Find the latest viseme whose time is <= elapsed
        const currentViseme = visemeSequence && visemeSequence.findLast(v => v.time <= elapsed);
        const mapped = currentViseme ? VISEME_MAP[currentViseme.value.toUpperCase()] : null;
        const morphName = mapped ? `viseme_${mapped}` : null;
        if(!morphName) return;
        // Head
        if (nodes.Wolf3D_Head) {
          setSingleMorph(
            nodes.Wolf3D_Head,
            MOUTH_VISEMES,
            morphName,
            1
          );
        }
        // Teeth
        if (nodes.Wolf3D_Teeth) {
          setSingleMorph(
            nodes.Wolf3D_Teeth,
            MOUTH_VISEMES,
            morphName,
            2
          );
        }
      }
      // Fallback: animate mouthOpen morph when isSpeaking is true
      else if (isSpeaking) {
        const t = performance.now() / 1000;
        const mouthValue = 0.3 + 0.2 * Math.abs(Math.sin(t * 6));
        if (nodes.Wolf3D_Head) {
          setSingleMorph(nodes.Wolf3D_Head, MOUTH_VISEMES, "mouthOpen", mouthValue);
        }
        if (nodes.Wolf3D_Teeth) {
          setSingleMorph(nodes.Wolf3D_Teeth, MOUTH_VISEMES, "mouthOpen", mouthValue);
        }
        // open the mouth
        // nodes.Wolf3D_Teeth.morphTargetInfluences[nodes.Wolf3D_Teeth.morphTargetDictionary['mouthOpen']] = 1;
        // nodes.Wolf3D_Head.morphTargetInfluences[nodes.Wolf3D_Head.morphTargetDictionary['mouthOpen']] = 1;
      }
      else {
        if (nodes.Wolf3D_Head) resetMorphs(nodes.Wolf3D_Head, MOUTH_VISEMES);
        if (nodes.Wolf3D_Teeth) resetMorphs(nodes.Wolf3D_Teeth, MOUTH_VISEMES);
      }
    });

    return (
      <group ref={ref || group} {...props} dispose={null}>
        <group name="Scene">
          <group name="AvatarRoot">
            <primitive object={nodes.Hips} />
            {/* <skinnedMesh name="Wolf3D_Hands" geometry={nodes.Wolf3D_Hands.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Hands.skeleton} /> */}
            <skinnedMesh name="Wolf3D_Hair" geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
            <skinnedMesh name="Wolf3D_Glasses" geometry={nodes.Wolf3D_Glasses.geometry} material={materials.Wolf3D_Glasses} skeleton={nodes.Wolf3D_Glasses.skeleton} />
            <skinnedMesh name="Wolf3D_Shirt" geometry={nodes.Wolf3D_Shirt.geometry} material={materials.Wolf3D_Shirt} skeleton={nodes.Wolf3D_Shirt.skeleton} />
            <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
            <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
            <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
            <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
          </group>
        </group>
      </group>
    );
  }
);

useGLTF.preload('models/68624e8f35fff28602dbc860.glb');
export default Avatar;
